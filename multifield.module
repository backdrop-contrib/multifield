<?php

//  field_attach_delete()
//  field_attach_form()
//  field_attach_form_validate()
//  field_attach_insert()
//  field_attach_load()
//  field_attach_load_revision()
//  field_attach_prepare_view()
//  field_attach_preprocess()
//  field_attach_presave()
//  field_attach_submit()
//  field_attach_update()
//X field_attach_validate()
//  field_attach_view()

require_once dirname(__FILE__) . '/multifield.field.inc';

/**
 * Implements hook_permission().
 */
function multifield_permission() {
  $info['administer multifield'] = array(
    'title' => t('Administer multifields'),
    'description' => t('Add, edit, or delete multifields.'),
    'restrict access' => TRUE,
  );

  return $info;
}

/**
 * Implements hook_menu().
 */
function multifield_menu() {
  $info['admin/structure/multifield'] = array(
    'title' => 'Multifield',
    'description' => 'Create and manage multifields and their subfields.',
    'page callback' => 'multifield_list_page',
    'access arguments' => array('administer multifield'),
    'file' => 'multifield.admin.inc',
  );
  $info['admin/structure/multifield/add'] = array(
    'title' => 'Add multifield type',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('multifield_edit_form'),
    'access arguments' => array('administer multifield'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'multifield.admin.inc',
  );
  $info['admin/structure/multifield/manage/%multifield'] = array(
    'title' => 'Edit multifield',
    'title callback' => 'multifield_page_title',
    'title arguments' => array(4),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('multifield_edit_form', 4),
    'access arguments' => array('administer multifield'),
    'file' => 'multifield.admin.inc',
  );
  $info['admin/structure/multifield/manage/%multifield/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $info['admin/structure/multifield/manage/%multifield/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('multifield_delete_form', 4),
    'access arguments' => array('administer multifield'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'multifield.admin.inc',
    'weight' => 100,
  );

  $info['multifield/field-remove-item/ajax'] = array(
    'title' => 'Remove item callback',
    'page callback' => 'multifield_field_widget_remove_item_ajax',
    'delivery callback' => 'ajax_deliver',
    'access callback' => TRUE,
    'theme callback' => 'ajax_base_page_theme',
    'type' => MENU_CALLBACK,
    'file' => 'multifield.field.inc',
  );

  return $info;
}

function multifield_page_title($multifield) {
  return check_plain($multifield->label);
}

/**
 * Implements hook_entity_info().
 */
function multifield_entity_info() {
  $info['multifield'] = array(
    'label' => t('Multifield'),
    'base table' => 'multifield',
    'fieldable' => TRUE,
    // Mark this as a configuratoin entity type to prevent other modules from
    // assuming they can do stuff with this entity type.
    'configuration' => TRUE,
    'bundle keys' => array(
      'bundle' => 'machine_name',
    ),
    'entity keys' => array(
      'id' => 'id',
      'bundle' => 'type',
    ),
  );

  // Bundles must provide a human readable name so we can create help and error
  // messages, and the path to attach Field admin pages to.
  foreach (multifield_load_all() as $machine_name => $multifield) {
    $info['multifield']['bundles'][$machine_name] = array(
      'label' => $multifield->label,
      'admin' => array(
        'path' => 'admin/structure/multifield/manage/%multifield',
        'real path' => 'admin/structure/multifield/manage/' . $machine_name,
        'bundle argument' => 4,
        'access arguments' => array('administer multifield'),
      ),
    );
  }

  return $info;
}

function multifield_load($name) {
  ctools_include('export');
  $result = ctools_export_load_object('multifield', 'names', array($name));
  return isset($result[$name]) ? $result[$name] : FALSE;
}

function multifield_load_all() {
  ctools_include('export');
  return ctools_export_crud_load_all('multifield');
}

function multifield_load_all_enabled() {
  $multifields = multifield_load_all();
  foreach ($multifields as $machine_name => $multifield) {
    if (!empty($multifield->disabled)) {
      unset($multifields[$machine_name]);
    }
  }
  return $multifields;
}

function multifield_save($multifield) {
  //$server->is_new = empty($server->sid);
  //module_invoke_all('redmine_server_presave', $server);
  ctools_include('export');
  ctools_export_crud_save('multifield', $multifield);
}

function multifield_type_save($multifield) {
  $return = NULL;
  module_invoke_all('multifield_type_presave', $multifield);

  if (!empty($multifield->mfid)) {
    // Existing record.
    $return = drupal_write_record('multifield', $multifield, array('machine_name'));
    module_invoke_all('mulifield_type_update', $multifield);
  }
  else {
    $return = drupal_write_record('multifield', $multifield, array());
    module_invoke_all('multifield_type_insert', $multifield);
    field_attach_create_bundle('multifield', $multifield->machine_name);
  }

  multifield_cache_clear();
  return $return;
}

function multifield_type_get_fields($multifield = NULL) {
  $fields = array();
  $map = field_info_field_map();
  foreach ($map as $field_name => $field) {
    if (!empty($multifield)) {
      if ($field['type'] == $multifield->machine_name) {
        $fields[$field_name] = $field_name;
      }
    }
    else {
      if (multifield_load($field['type'])) {
        $fields[$field_name] = $field_name;
      }
    }
  }
  return $fields;
}

function multifield_type_has_instances($machine_name) {
  $map = field_info_field_map();
  foreach ($map as $field_name => $field) {
    if ($field['type'] == $machine_name) {
      return TRUE;
    }
  }

  return FALSE;
}

function multifield_delete($name) {
  if ($multifield = multifield_load($name)) {
    ctools_include('export');
    return ctools_export_crud_delete('multifield', $multifield);
  }
}

function multifield_delete($multifield) {
  module_invoke_all('multifield_delete', $multifield);

  db_delete('multifield')
    ->condition('machine_name', $multifield->machine_name)
    ->execute();

  field_attach_delete_bundle('multifield', $multifield->machine_name);
  multifield_cache_clear();
}

/**
 * Implements hook_multifield_delete() on behalf of field module.
 */
function field_multifield_delete($multifield) {
  // Any fields created from this multifield must also be deleted.
  if ($fields = multifield_type_get_fields($multifield)) {
    foreach ($fields as $field_name) {
      field_delete_field($field_name);
    }
  }
}

function multifield_cache_clear() {
  field_info_cache_clear();
  variable_set('menu_rebuild_needed', TRUE);
}

function multifield_field_machine_name_exists($name) {
  return field_info_field_types($name) || multifield_load($name);
}

function multifield_get_subfields($machine_name = NULL) {
  $fields = &drupal_static(__FUNCTION__);

  if (!isset($fields)) {
    foreach (field_info_field_map() as $field_name => $field) {
      if (!empty($field['bundles']['multifield'])) {
        foreach ($field['bundles']['multifield'] as $bundle) {
          if (!isset($fields[$bundle])) {
            $fields[$bundle] = array();
          }
          $fields[$bundle][] = $field_name;
        }
      }
    }
  }

  if (isset($machine_name)) {
    return !empty($fields[$machine_name]) ? $fields[$machine_name] : array();
  }
  else {
    return $fields;
  }
}

function _multifield_field_item_to_entity($machine_name, array $item, array $additional = array()) {
  $pseudo_entity = new stdClass();
  $pseudo_entity->id = !empty($item['id']) ? $item['id'] : NULL;
  $pseudo_entity->type = $machine_name;
  foreach (array_intersect_key($item, field_info_instances('multifield', $machine_name)) as $field => $values) {
    $pseudo_entity->{$field} = $item[$field];
  }
  foreach ($additional as $key => $value) {
    $pseudo_entity->{$key} = $value;
  }
  return $pseudo_entity;
}

function _multifield_field_entity_to_item($pseudo_entity) {
  $item = (array) $pseudo_entity;
  $item = array_intersect_key($item, field_info_instances('multifield', $pseudo_entity->type));
  $item['id'] = $pseudo_entity->id;
  //$item['#pseudo_entity'] = $pseudo_entity;
  return $item;
}

function multifield_item_unserialize(&$item, $delta, $multifield) {
  foreach (multifield_get_subfields($multifield['type']) as $subfield_name) {
    $subfield = field_info_field($subfield_name);
    foreach (array_keys($subfield['columns']) as $column) {
      if (array_key_exists($subfield_name . '_' . $column, $item)) {
        $item[$subfield_name][LANGUAGE_NONE][0][$column] = $item[$subfield_name . '_' . $column];
        unset($item[$subfield_name . '_' . $column]);
      }
    }
  }
}

function multifield_item_serialize(&$item, $delta, $multifield) {
  // Serialize the multifield values into separate columns for saving into the
  // field table.
  foreach (field_info_instances('multifield', $multifield['type']) as $subfield_name => $subfield_instance) {
    $subfield = field_info_field($subfield_name);
    foreach ($subfield['columns'] as $column => $details) {
      if (isset($item[$subfield_name][LANGUAGE_NONE][0][$column])) {
        // We need to assign this value by reference because
        // $items[$delta][$subfield_name] could be modified in
        // multifield_field_insert() or multifield_field_update().
        $item[$subfield_name . '_' . $column] = &$item[$subfield_name][LANGUAGE_NONE][0][$column];
      }
      else {
        // @see field_sql_storage_field_storage_write()
        $item[$subfield_name . '_' . $column] = isset($details['default']) ? $details['default'] : NULL;
      }
    }
    //unset($item[$subfield_name]);
  }
}

function multifield_get_next_id() {
  $id = &drupal_static(__FUNCTION__);
  if (!isset($id)) {
    $id = variable_get('multifield_max_id', 0);
  }
  return ++$id;
}

function multifield_update_maximum_id(array $items) {
  if (!empty($items)) {
    $ids = array();
    foreach ($items as $item) {
      $ids[] = $item['id'];
    }
    $largest_id = max($ids);
    if ($largest_id > variable_get('multifield_max_id', 0)) {
      variable_set('multifield_max_id', $largest_id);
      drupal_static_reset('multifield_get_next_id');
    }
  }
}

// @todo Remove this function?
function _multifield_generate_unique_id() {
  $seen_ids = &drupal_static(__FUNCTION__, array());
  do {
    $id = mt_rand();
  }
  while (isset($seen_ids[$id]));
  $seen_ids[$id] = TRUE;

  return $id;
}

/**
 * Implements hook_form_FORM_ID_alter() for field_ui_field_overview_form().
 */
function multifield_form_field_ui_field_overview_form_alter(&$form, &$form_state) {
  if ($form['#entity_type'] != 'multifield') {
    return;
  }

  // Prevent multifields from being added to multifields themselves.
  $form['fields']['_add_new_field']['type']['#options'] = array_diff_key($form['fields']['_add_new_field']['type']['#options'], multifield_load_all());
  if (isset($form['fields']['_add_existing_field'])){
    $form['fields']['_add_existing_field']['field_name']['#options'] = array_diff_key($form['fields']['_add_existing_field']['field_name']['#options'], multifield_type_get_fields());
  }

  // Prevent changes being made if this multifield type has instances.
  if (multifield_type_has_instances($form['#bundle'])) {
    drupal_set_message(t('The fields for this multifield cannot be changed since it has instances.'), 'warning');
    $form['fields']['_add_new_field']['#access'] = FALSE;
    $form['fields']['_add_existing_field']['#access'] = FALSE;
    unset($form['fields']['#regions']['add_new']);
    foreach ($form['#fields'] as $field_name) {
      //$form['fields'][$field_name]['edit'] = array('#markup' => t('Locked'));
      $form['fields'][$field_name]['delete'] = array();
      //$form['fields'][$field_name]['#attributes']['class'][] = 'menu-disabled';
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for field_ui_field_edit_form().
 */
function multifield_form_field_ui_field_edit_form_alter(&$form, &$form_state) {
  if ($form['#instance']['entity_type'] != 'multifield') {
    return;
  }

  // Show a notice that multifield subfields have a cardinality of one value
  // enforced in the widget.
  $form['field']['cardinality']['#disabled'] = TRUE;
  $form['field']['cardinality']['#field_prefix'] = '<div class="messages warning">' . t('Field cardinality in multifields is limited to one value despite this setting.') . '</div>';

  // Hide the default value widget since we want the user to set the default
  // value for this entire multifield instead.
  if (isset($form['instance']['default_value_widget'])) {
    $form['instance']['default_value_widget']['#access'] = FALSE;
  }

  // If this multifield has instances, make sure that no field settings that
  // could change the field schema can be edited by re-invokin
  // hook_field_settings_form() with $has_data forced to be TRUE.
  if (multifield_type_has_instances($form['#instance']['bundle'])) {
    $field = $form['#field'];
    $instance = $form['#instance'];
    $has_data = field_has_data($field);
    if (!$has_data) {
      $additions = module_invoke($field['module'], 'field_settings_form', $field, $instance, TRUE);
      if (is_array($additions)) {
        $form['field']['settings'] = $additions;
      }
    }
  }
}

function multifield_form_field_ui_field_settings_form_alter(&$form, &$form_state) {
  if ($form['#entity_type'] == 'multifield' && multifield_type_has_instances($form['#bundle'])) {
    $instance = $form_state['build_info']['args'][0];
    $field = field_info_field($instance['field_name']);
    $has_data = field_has_data($field);
    if (!$has_data) {
      $additions = module_invoke($field['module'], 'field_settings_form', $field, $instance, TRUE);
      if (is_array($additions)) {
        $form['field']['settings'] = $additions;
      }
    }
  }
}

function multifield_form_field_ui_field_delete_form_alter(&$form, &$form_state) {
  $instance = $form_state['build_info']['args'][0];
  if ($instance['entity_type'] == 'multifield' && multifield_type_has_instances($instance['bundle'])) {
    $field = field_info_field($instance['field_name']);
    if (!$field['locked']) {
      $form['description']['#markup'] = '<div class="messages error">' . t('This field cannot be deleted since this multifield has instances.') . '</div>';
      unset($form['actions']['submit']);
    }
  }
}

/**
 * Implements hook_views_data_alter().
 */
function multifield_views_data_alter(array &$data) {
  // Remove any references to the fake multifield table.
  unset($data['multifield']);
  unset($data['entity_multifield']);
  unset($data['views_entity_multifield']);
  foreach ($data as &$table) {
    unset($table['table']['join']['multifield']);
    unset($table['table']['default_relationship']['multifield']);
  }
}

function multifield_type_get_names() {
  $names = &drupal_static(__FUNCTION__, array());
  foreach (multifield_load_all() as $machine_name => $multifield) {
    $names[$machine_name] = $multifield->label;
  }
  return $names;
}

/**
 * Implements hook_admin_menu_map().
 */
function multifield_admin_menu_map() {
  if (!user_access('administer multifield')) {
    return;
  }

  $multifields = multifield_load_all();
  $map['admin/structure/multifield/manage/%multifield'] = array(
    'parent' => 'admin/structure/multifield',
    'arguments' => array(
      array('%multifield' => array_keys($multifields)),
    ),
  );

  // Support the Field UI mappings.
  if (module_exists('field_ui')) {
    $arguments = array();
    foreach ($multifields as $machine_name => $multifield) {
      $instances = field_info_instances('multifield', $machine_name);
      $arguments[] = array(
        '%multifield' => array($machine_name),
        '%field_ui_menu' => array_keys($instances),
      );
    }
    $map['admin/structure/multifield/manage/%multifield/fields/%field_ui_menu'] = array(
      'parent' => 'admin/structure/multifield/manage/%multifield/fields',
      'arguments' => $arguments,
    );
  }
  return $map;
}
